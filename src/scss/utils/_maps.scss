// See https://www.sitepoint.com/extra-map-functions-sass/ for examples

// a map-set function
@function map-set($map, $key, $value) {
  $new: ($key: $value);
  @return map-merge($map, $new);
}

/// Fetch nested keys
/// @param {Map} $map - Map
/// @param {Arglist} $keys - Keys to fetch
/// @return {*}
@function map-deep-get($map, $keys...) {
  @each $key in $keys {
    $map: map-get($map, $key);
  }

  @return $map;
}

/// Update a key deeply nested
/// @param {Map} $map - Map to update
/// @param {Arglist} $keys - Keys to access to value to update
/// @param {*} $value - New value (last member of `$keys`)
/// @return {Map} - Updated map
@function map-deep-set($map, $keys.../*, $value */) {
  $map-list: ($map,);
  $result: null;

  @if length($keys) == 2 {
    @return map-merge($map, (nth($keys, 1): nth($keys, -1)));
  }

  @for $i from 1 through length($keys) - 2 {
    $map-list: append($map-list, map-get(nth($map-list, -1), nth($keys, $i)));
  }

  @for $i from length($map-list) through 1 {
    $result: map-merge(nth($map-list, $i), (nth($keys, $i): if($i == length($map-list), nth($keys, -1), $result)));
  }

  @return $result;
}

/// Test if map got all `$keys` at first level
/// @param {Map} $map - Map
/// @param {Arglist} $keys - Keys to test
/// @return {Bool}
@function map-has-keys($map, $keys...) {
  @each $key in $keys {
    @if not map-has-key($map, $key) {
      @return false;
    }
  }

  @return true;
}

/// Test if map keys have partial at first level
/// @param {Map} $map - Map
/// @param {Arglist} $keys - Keys to test
/// @return {Bool}
@function map-has-key-partial($map, $partial) {
  @each $key in $map {
    @if(str-index($key, $partial)) {
      @return true;
    }
  }
  @return false;
}

/// Test if map got all `$keys` nested with each others
/// @param {Map} $map - Map
/// @param {Arglist} $keys - Keys to test
/// @return {Bool}
@function map-has-nested-keys($map, $keys...) {
  @each $key in $keys {
    @if not map-has-key($map, $key) {
      @return false;
    }
    $map: map-get($map, $key);
  }

  @return true;
}

// Merge nested maps
@function map-deep-merge($map-old, $map-new, $overwrite: true){
  // Iterate through each value of the new map
  @each $key, $new-value in $map-new {
    // Check if that value already exists on the old map
    @if map-has-key($map-old, $key) {

      $old-value: map-get($map-old, $key);
      $new-value-is-map: type-of($new-value) == map;
      $old-value-is-map: type-of($old-value) == map;

      // If both are maps, recurse regardless of $overwrite
      @if $old-value-is-map and $new-value-is-map {
        $merged-value: map-deep-merge($old-value, $new-value);
        $map-old: map-set($map-old, $key, $merged-value);
      }@else{
        // Otherwise check $overwrite
        @if $overwrite{
          $map-old: map-set($map-old, $key, $new-value);
        }
      }
    // There is no existing key so add
    }@else{
      $map-old: map-set($map-old, $key, $new-value);
    }
  }
  @return $map-old
}

// Debug maps
@mixin debug-map($map) {
    @at-root {
        @debug-map {
            __toString__: inspect($map);
            __length__: length($map);
            __depth__: depth($map);
            __keys__: map-keys($map);
            __properties__ {
                @each $key, $value in $map {
                    #{'(' + type-of($value) + ') ' + $key}: inspect($value);
                }
            }
        }
    }
}
