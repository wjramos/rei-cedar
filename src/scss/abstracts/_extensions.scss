// Mixin for parsing maps returned from theo and creating styles encoded within
// @param {Map} $variantMap - map created by theo
// @return {scss} ouputs the css defined in the map
@mixin create-extension-styles($variantMap) {
  @each $variantName, $map in $variantMap {
    // unique placeholder in case of no defined class
    // TODO/QUESTION: better idea?
    $fullClass: class-#{unique-id()};

    // TODO/QUESTION: do we want other reserved keys like/besides class?
    // if class defined -> set variable and remove it so it's only css properties left
    @if (map-has-key($map, 'class')) {
      $className: map-get($map, class);
      $fullClass: #{$prefix}#{$className};
      $map: map-remove($map, class);
    }

    // prepopulate map with breakpoint values
    $extension-style-map: ();
    @each $key, $value in $mq-breakpoints {
      $extension-style-map: map-set($extension-style-map, #{$key}, ());
    }

    // build out map with all styles organized by breakpoints and element specifics
    @each $key, $val in $map {
      $split: _split($key, $varDelimiter);
      $mod: false;
      $prop: false;
      $breakpoint: false;
      @each $item in $split {
        $allGood: false; // hack because sass can't break loops

        @if (is-def($item, $modifierDef)) {
          // QUESTION: do we need element limiting?
          // $el: get-el(strip-def($item, $modifierDef));
          $mod: strip-def($item, $modifierDef);
          $allGood: true;
        } @else if (is-def($item, $propertyDef)) {
          $prop: get-prop(strip-def($item, $propertyDef));
          $allGood: true;
        } @else if (is-def($item, $breakpointDef)) {
          $breakpoint: get-bp(strip-def($item, $breakpointDef), $extension-style-map);
          $allGood: true;
        } @else if not($allGood) {
          @warn '\'#{$key}\' did not match formatting of defined types: {<element>} (<property>) [<breakpoint>]';
        }
      }

      // if no breakpoint set, assume it's small/general (mobile-first)
      @if not($breakpoint) {
        $extension-style-map: generate-style-map($key, $val, $extension-style-map, $zero-breakpoint, $prop, $mod);
      }@else {
        $extension-style-map: generate-style-map($key, $val, $extension-style-map, $breakpoint, $prop, $mod);
      }
    }

    // Heading styles
    .#{$fullClass} {
      @include parse-mapped-styles($extension-style-map);
    }

  }
}

// Parses mapped styles (also see build-mapped-styles mixin below)
// @param {Map} $map - Map with breakpoint and style definitions
// @returns - none (see build-mapped-styles mixin below)
@mixin parse-mapped-styles($map) {
  @each $key, $value in $map {
    //only make a media query for things above small (mobile-first)
    @if $key != $zero-breakpoint {
      @include mq($key) {
        @include build-mapped-styles($value);
      }
    } @else {
      @include build-mapped-styles($value);
    }
  }
}

// Generates CSS for correctly formatted style maps, recurses for nested maps
// @param {Map} $defs - Map, or nested map, of styles
// @returns {scss} outputs the css defined in the map
@mixin build-mapped-styles($defs) {
  @each $key, $val in $defs {
    // if a map, chain a class and get the values
    @if type-of($val) == map {
      &.-#{$key} {
        @include build-mapped-styles($val);
      }
    }
    @else {
      /// QUESTION/NOTE/TODO: need to enforce/limit to known good values?
      /// in order to set things like units (px vs rem vs unitless)
      // @if ($key == font-size) {
      //   font-size: rem-calc(to-number($val));
      // }
      // @else if ($key == font-weight) {
      //   font-weight: $val;
      // }
      /// QUESTION/NOTE: OR trust what is given?
      #{$key}: #{$val};
    }
  }
}

// Check if definition is properly formatted
// @param {string} $input - map key partial; i.e. {h1}
// @param {string} $delim - space separated symbols for grouping; i.e. { }
// @return {boolean} is or isn't formatted as a valid definition
@function is-def($input, $delim) {
  // split space separated definition
  $delims: _split($delim, ' ');
  $begin: _first($delims);
  $end: _last($delims);

  // verify valid formatting as definition
  @if (_starts-with($input, $begin)) {
    @if (_ends-with($input, $end)) {
      @return true;
    }
  }

  @return false;
}

// Strip delimiters from definitions
// @param {string} $input - parsed breakpoint partial
// @param {string} $delim - space separated delimiters
// @return {string} $out - delimiter stripped definition
@function strip-def($input, $delim) {
  // split space separated definition
  $delims: _split($delim, ' ');

  // remove delimiters to get raw value
  $out: _trim($input, $delims);

  @return $out;
}

// Match breakpoints to verify they are defined
// @param {string} $input - parsed breakpoint partial
// @param {Map} $map - map with breakpoints defined
// @return {string} $name - matched known defined breakpoint value or false
@function get-bp($input, $map) {
  @each $name, $val in $map {
    @if ($input == $name) {
      @return $name;
    }
  }
  @debug 'Nothing matched in breakpoint definitions: \'#{$input}\'';
  @return false;
}

// Take parsed values and output a correclty formatted style map
// @param {string} $key - key from parent map
// @param {string} $val - value from parent map (contains css property value)
// @param {map} $baseMap - the style map that we will be adding to
// @param {string} $bp - breakpoint key for nested map (parsed from key beforehand)
// @param {string} $prop - css property (parsed from key beforehand)
// @param *optional {string} $mod - modifier class (parsed from key beforehand)
// @return {map} $returnMap - Updated map
@function generate-style-map($key, $val, $baseMap, $bp, $prop, $mod:false) {
  // is a modifier
  @if ($mod) {
    // set up element map if there isn't one
    @if not(map-has-nested-keys($baseMap, #{$bp}, #{$mod})) {
      $newModMap: map-deep-set($baseMap, #{$bp}, (#{$mod}:()));
      $baseMap: map-deep-merge($baseMap, $newModMap);
    }
    $newMap: map-deep-set($baseMap, #{$bp}, #{$mod}, #{$prop}, #{$val});
    $returnMap: map-deep-merge($baseMap, $newMap);
    @return $returnMap;
  }
  // not a modifier
  @else {
    $returnMap: map-deep-set($baseMap, #{$bp}, #{$prop}, #{$val});
    @return $returnMap;
  }
}
